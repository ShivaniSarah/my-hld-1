8 Distributed Email Service

In this chapter, we design a large-scale email service like Gmail, Outlook, or Yahoo Mail.

The internet‚Äôs growth has caused a massive explosion in email volume. For example:

In 2020, Gmail had over 1.8 billion active users.

Outlook had over 400 million users worldwide.

Popular providers include:

outlook.com

gmail.com

yahoo.com

Step 1 - Understand the Problem and Establish Design Scope

Modern email services are very complex with lots of features. 
Since we can‚Äôt design the entire system in a short time, it‚Äôs important to ask clarifying questions and narrow down the scope.

Example Interview Dialogue

Candidate: How many people use the product?
Interviewer: 1 billion users.

Candidate: I think the following features are important:

Send and receive emails

Fetch all emails

Filter emails by read/unread status

Search emails by subject, sender, and body

Anti-spam and anti-virus

Interviewer: Good list! Let‚Äôs not worry about authentication for now. We‚Äôll focus on the other features.

Candidate: How do users connect with mail servers?
Interviewer: Traditionally via SMTP, POP, IMAP, and vendor-specific protocols. 
But for this interview, assume HTTP is used for client-server communication.

Candidate: Can emails have attachments?
Interviewer: Yes.

Non-functional Requirements

Reliability

Emails should never be lost.

Availability

User data and emails must be replicated across multiple nodes.

The system should still function even if parts of it fail.

Scalability

The system should handle growing numbers of users and emails.

Performance should not degrade with scale.

Flexibility and Extensibility

The system should support adding new features easily.

Traditional protocols (POP, IMAP) are limited.

We may need custom protocols to meet modern needs.

Back-of-the-envelope Estimation

Since emails are storage-heavy, let‚Äôs estimate scale:

Users: 1 billion

Emails sent per person per day: 10

Total QPS (queries per second) for sending:

109√ó10/105‚âà100,000109√ó10/105‚âà100,000

Emails received per person per day: 40

Average metadata size: 50 KB

Metadata storage for 1 year:

1ùêµ√ó40√ó365√ó50ùêæùêµ=730
‚Äâ
ùëÉùêµ1B√ó40√ó365√ó50KB=730PB

Attachments: 20% of emails have one

Average attachment size: 500 KB

Attachment storage for 1 year:

1ùêµ√ó40√ó365√ó20%√ó500ùêæùêµ=1,460ùëÉùêµ

1B√ó40√ó365√ó20%√ó500KB=1,460PB

üëâ Clearly, this requires a distributed database solution.

Step 2 - Propose High-level Design and Get Buy-in

We now discuss email basics, traditional mail servers, and distributed mail servers.

Email Knowledge 101

Different email protocols are used to send/receive emails:

SMTP (Simple Mail Transfer Protocol)

Standard protocol for sending emails between mail servers.

POP (Post Office Protocol)

Used to download emails from server to local client.

Once downloaded, emails are deleted from the server.

Means emails are only available on one device.

Requires downloading the entire email, including attachments.

Defined in RFC 1939.

IMAP (Internet Mail Access Protocol)

Used to read emails from server.

Emails are kept on the server (can be accessed from multiple devices).

Only downloads email headers first, body only when clicked.

Much better for slow connections.

Most widely used protocol for individuals.

HTTPS (Web Access)

Not technically a mail protocol.

Commonly used by web-based clients.

Example: Microsoft Outlook uses ActiveSync over HTTPS for mobile devices.

Domain Name Service (DNS)

DNS servers are used to look up the MX (Mail Exchanger) record of a recipient‚Äôs domain.

Example: running DNS lookup for gmail.com returns MX records.

Each record has a priority number:

Lower number = higher priority.

Example:

gmail-smtp-in.1.google.com (priority 5) is tried first.

If it fails, the sender tries alt1.gmail-smtp-in.1.google.com (priority 10), and so on.

This ensures reliable delivery even if some servers are down.





Attachment

An email attachment is a file that is sent along with an email message.

Attachments are usually Base64 encoded so that binary files (like images, PDFs, etc.) can be sent safely over text-based email protocols.

Size limits exist:

Outlook ‚Üí 20 MB

Gmail ‚Üí 25 MB (as of June 2021).

These limits vary depending on the type of account (individual vs. corporate).

MIME (Multipurpose Internet Mail Extension):
A standard specification that enables sending different types of attachments (text, audio, video, etc.) over email.

Traditional Mail Servers

Before distributed systems, emails were handled by traditional single-server mail servers. These worked well for a limited number of users but were not scalable.

Traditional Mail Server Architecture

When Alice (alice@outlook.com
) sends an email to Bob (bob@gmail.com
), the process has 4 steps:

Alice sends email:

Alice composes an email in Outlook client.

The email is sent to the Outlook mail server.

Protocol used: SMTP (Simple Mail Transfer Protocol).

Outlook mail server forwards email:

Outlook server queries the DNS to locate the recipient‚Äôs SMTP server (in this case, Gmail‚Äôs SMTP server).

The email is transferred to Gmail‚Äôs SMTP server.

Protocol used: SMTP (server-to-server communication).

Gmail server stores email:

Gmail mail server stores the email in its storage system.

It becomes available for Bob to retrieve.

Bob fetches email:

When Bob logs in to Gmail, the Gmail client fetches the email from Gmail‚Äôs IMAP/POP server.

Protocol used: IMAP (Internet Message Access Protocol) or POP (Post Office Protocol).

Storage

In traditional systems, emails were stored in local file directories.

Each email was a separate file with a unique name.

Each user had a directory storing:

Mailboxes

Configuration data

Maildir Format

A popular way of organizing email storage.
Structure:

home/
   user1/
       Maildir/
           cur/
           new/
           tmp/
   user2/
       Maildir/
           cur/
           new/
           tmp/


cur/ ‚Üí read messages

new/ ‚Üí new messages

tmp/ ‚Üí temporary storage

Problems with this approach:

Worked well for small users, but failed at scale:

Hard to retrieve & back up billions of emails.

Disk I/O bottleneck when storage became huge.

Not highly available or reliable (disk/server failure risk).

Evolution of Email

Started in the 1960s with only text.

Modern email now supports:

Multimedia

Threading

Search

Labels, etc.

However, old protocols (POP, IMAP, SMTP) were not designed for scale ‚Üí they struggle with billions of users and new features.

Distributed Mail Servers

Modern mail servers are distributed to handle scale, reliability, and modern features.

Email APIs

"Email APIs" vary depending on context:

SMTP/POP/IMAP APIs ‚Üí for native mobile/desktop clients.

SMTP ‚Üí for communication between sender & receiver servers.

RESTful APIs (over HTTP) ‚Üí for modern webmail applications.

Common Webmail APIs

Send Email

Endpoint: POST /v1/messages

Sends messages to recipients in To, Cc, Bcc.

List Folders

Endpoint: GET /v1/folders

Returns all folders of a user.

Example folders (per RFC6154): All, Archive, Drafts, Flagged, Junk, Sent, Trash.

Response includes:

id (folder ID)

name (folder name)

user_id (owner reference)

List Messages in a Folder

Endpoint: GET /v1/folders/{folder_id}/messages

Returns all messages under a folder.

Needs pagination in real-world usage.

Get a Specific Message

Endpoint: GET /v1/messages/{message_id}

Returns detailed information about a specific message.

Response includes:

Sender (name, email)

Recipients (list of name/email)

Subject

Body

Attachments

Read status

Distributed Mail Server Architecture

Scaling email requires multiple servers with different responsibilities.

High-Level Design (Figure 8.5)

Components:

Webmail

Users access emails via browsers.

Web Servers

Handle user-facing requests: login, signup, user profile, sending emails, fetching folders/messages.

All API requests go through web servers.

Real-Time Servers

Push new email updates instantly to clients.

Stateful servers (maintain persistent connections).

Support real-time communication via:

WebSocket (preferred, elegant, real-time).

Long polling (fallback when WebSocket not supported).

Example: Apache James ‚Üí supports JMAP (JSON Meta Application Protocol) over WebSocket.

Metadata Database

Stores mail metadata (subject, body, sender, recipients, etc.).

Choice of database depends on scalability and query needs.

Attachment Store

Handles file attachments separately from metadata for efficiency.

Distributed Cache

Speeds up frequently accessed data.

Search Store

Optimized for searching through emails quickly (e.g., indexing).

Storage Layer

Handles large-scale, reliable, distributed storage for email data.



Attachment Store

For storing attachments (images, videos, files, etc.), we use an object store like Amazon S3.

Reasons for using S3:

It is scalable and can handle very large files.

Attachments can be up to 25 MB in size, which is a good fit for object stores.

Why Cassandra is not a good fit for attachments:

Even though Cassandra supports the BLOB data type (theoretical max size = 2 GB), the practical limit is much smaller (less than 1 MB).

Storing large attachments in Cassandra prevents efficient row caching, since attachments take up too much memory space.

Distributed Cache

Since recent emails are the most frequently accessed, keeping them in cache memory greatly reduces load time.

Redis is a great choice because:

It supports rich data structures like lists.

It is easy to scale horizontally.

Search Store

For searching emails, we use a distributed document store.

It is based on an inverted index data structure.

This allows fast full-text search, which is critical for email systems.

The deep dive section (not shown here) would explain how the inverted index works in detail.

Workflows

The system has two main workflows:

Email Sending Flow

Email Receiving Flow

Right now, the focus is on the Email Sending Flow.

Email Sending Flow

(Figure 8.6 in the text illustrates this flow.)

Step 1: User Action

A user writes an email in webmail and presses Send.

The request goes to the Load Balancer.

Step 2: Load Balancer

Ensures the system does not exceed rate limits.

Routes the request to the web servers.

Step 3: Web Servers

Perform multiple tasks:

Basic validation of the email: e.g., check if the email size is within allowed limits.

Domain check: if the recipient‚Äôs email domain is the same as the sender‚Äôs:

The web server checks for spam and viruses.

If clean, the email is directly inserted into:

The sender‚Äôs Sent Folder.

The recipient‚Äôs Inbox Folder.

The recipient can fetch the email directly via REST API.

In this case, steps after this are not needed (no SMTP outgoing flow).

Step 4: Message Queues

If the email passes validation, it goes to the outgoing queue.

If validation fails, it goes to the error queue.

Details:

Outgoing queue:

Contains valid emails.

If the attachment is too large, it is stored in the object store (S3).

A reference link to the attachment is saved in the message.

Error queue:

Holds emails that failed validation.

Step 5: SMTP Outgoing Workers

These workers pull messages from the outgoing queue.

Tasks performed:

Ensure the email is spam-free and virus-free before sending.

Step 6: Storage Layer

The outgoing email is stored in the sender‚Äôs Sent Folder inside the database/storage layer.

Step 7: SMTP Delivery

SMTP outgoing workers send the email to the recipient‚Äôs mail server over the Internet.

Message Queue Importance

Each message in the queue contains all metadata needed to construct the email.

The message queue provides asynchronous processing, meaning web servers don‚Äôt wait for SMTP delivery.

Scaling advantage:

SMTP workers are decoupled from web servers.

We can scale SMTP workers independently depending on traffic.

Monitoring Outgoing Queue

The outgoing queue must be monitored continuously.
If too many emails are stuck in the queue, possible reasons include:

Recipient mail server unavailable:

Solution: Retry later using exponential backoff (increasing wait times between retries).

Not enough consumers (workers):

Solution: Add more SMTP workers to process the queue faster.



üì© Email Receiving Flow

The email receiving flow describes how incoming emails are handled by the system, from SMTP load balancer entry to being delivered to the user‚Äôs inbox (either in real time or when they come back online).

1. Incoming Emails at SMTP Load Balancer

All incoming emails first arrive at the SMTP load balancer.

The load balancer distributes traffic among SMTP servers.

At this stage, an Email Acceptance Policy can be applied (e.g., invalid emails are bounced immediately to avoid wasting resources).

2. Attachment Handling

If an email attachment is too large to put into the queue, it is stored separately in the Attachment Store (e.g., Amazon S3).

3. Incoming Email Queue

Emails are placed in the incoming email queue.

This queue decouples SMTP servers from mail processing workers, so they can scale independently.

The queue also acts as a buffer during traffic spikes.

4. Mail Processing Workers

These workers handle:

Spam filtering

Virus scanning

Other email validations

Only emails that pass validation continue through the flow.

5. Storage

Emails are stored in the:

Mail storage (main database)

Cache (for quick access to recent emails)

Object store (attachments, large objects, etc.)

6. Real-Time Delivery

If the receiver is online, the email is pushed to real-time servers.

These are WebSocket servers that allow instant email delivery to clients.

7. Offline Delivery

If the receiver is offline, the email stays in the storage layer.

When the user comes back online, their webmail client connects to web servers via RESTful API.

The web servers pull new emails from storage and deliver them to the client.

üîç Step 3 ‚Äì Design Deep Dive

Now we examine the key components of the email server in more depth, especially focusing on scalability.

Metadata Database
Characteristics of Email Metadata

Headers: Small, frequently accessed.

Bodies: Can be large, but infrequently accessed (users usually read once).

Isolation: Email operations (fetch, mark as read, search) are per user only.

Recency effect: Most queries are for recent data (82% within 16 days).

Reliability: Extremely high reliability needed (data loss not acceptable).

Choosing the Right Database

Relational Databases (MySQL/Postgres)

Pros: Indexing for fast searches.

Cons: Emails are often large (100KB+ with HTML), BLOB searches inefficient ‚Üí not ideal.

Distributed Object Storage (e.g., S3)

Pros: Great for backup of raw emails.

Cons: Poor for user-facing features (mark as read, search, threading).

NoSQL Databases

Gmail uses Bigtable (custom implementation, not open source).

Cassandra could work but has not been proven at large email provider scale.

‚úÖ Characteristics an Ideal Email Database Must Have:

Handle single columns of size up to MBs.

Strong consistency.

Reduced disk I/O.

High availability and fault tolerance.

Easy incremental backups.

Attachment Store

Attachments stored in Amazon S3 (object storage).

Scalable and designed for large files (images, videos, docs).

Attachments can be up to 25MB.

‚ùå Why not Cassandra?

Practical blob size limit (< 1MB).

Large blobs break row cache efficiency.

Distributed Cache

Used to store recent emails in memory.

Greatly improves load time for clients.

Redis is a good fit because:

Supports lists and other structures.

Easy to scale.

Search Store

Implemented as a distributed document store.

Uses inverted index data structure.

Supports fast full-text search.

üì§ Email Sending Flow

The email sending flow describes how emails are processed when a user sends an email.

1. Sending Email

A user writes an email in webmail and hits send.

The request is sent to the load balancer.

2. Load Balancer

Ensures rate limiting.

Routes request to the web servers.

3. Web Servers

Responsible for:

Basic validation (e.g., size limits).

Domain check (if sender and recipient are on the same domain).

If yes ‚Üí check for spam & viruses, then directly insert email into:

Sender‚Äôs Sent Folder

Recipient‚Äôs Inbox Folder

In this case, recipient fetches email via REST API (skip queue).

4. Message Queues

Outgoing queue: Valid emails go here.

If attachment is too large ‚Üí store in object store, reference it in queue.

Error queue: Invalid emails go here.

5. SMTP Outgoing Workers

Pull messages from outgoing queue.

Ensure emails are spam & virus free.

6. Storage

Outgoing email is saved in Sent Folder of the storage layer.

7. Send to Recipient

SMTP outgoing workers deliver the email to the recipient mail server.

Importance of Outgoing Queue

Contains all metadata needed to reconstruct email.

Allows asynchronous processing.

Decouples web servers from SMTP workers ‚Üí enables independent scaling.

Monitoring Outgoing Queue

If backlog grows, investigate:

Recipient‚Äôs server is down ‚Üí retry later using exponential backoff.

Not enough SMTP workers ‚Üí scale up consumers.



Data Model

An email service requires an efficient data model to store and retrieve emails at scale. A NoSQL column-family database (like Cassandra) is suitable because of its ability to handle large amounts of distributed data.

Partition Key: Distributes data across nodes in the cluster. Choosing the right partition key ensures data is evenly spread.

Clustering Key: Determines the order of data within a partition, enabling sorted queries (e.g., emails sorted by time).

For this design, user_id is often used as the partition key to keep all of a user‚Äôs data (folders, emails) together on a single shard.

Queries

The email service needs to support several important queries at the data layer.

Query 1: Get all folders for a user

Each user has multiple folders (Inbox, Sent, Drafts, etc.).

The table folders_by_user uses user_id as the partition key, ensuring all folders of one user are grouped together.

Table: folders_by_user


| Column       | Type | Key            |
| ------------ | ---- | -------------- |
| user\_id     | UUID | Partition Key  |
| folder\_id   | UUID | Clustering Key |
| folder\_name | TEXT | ‚Äì              |



This allows efficient retrieval of all folders for a specific user.

Query 2: Display all emails for a specific folder

When a folder is opened (e.g., Inbox), emails should be retrieved sorted by timestamp (most recent first).

To achieve this, a composite partition key (user_id, folder_id) is used.

email_id is a TIMEUUID and acts as the clustering key to maintain chronological order.

Table: emails_by_folder

| Column     | Type     | Key                               |
| ---------- | -------- | --------------------------------- |
| user\_id   | UUID     | Partition Key (part of composite) |
| folder\_id | UUID     | Partition Key (part of composite) |
| email\_id  | TIMEUUID | Clustering Key                    |
| from       | TEXT     | ‚Äì                                 |
| subject    | TEXT     | ‚Äì                                 |
| preview    | TEXT     | ‚Äì                                 |
| is\_read   | BOOLEAN  | ‚Äì                                 |



Another supporting table:

Table: emails_by_user

| Column      | Type           | Key            |   |
| ----------- | -------------- | -------------- | - |
| user\_id    | UUID           | Partition Key  |   |
| email\_id   | TIMEUUID       | Clustering Key |   |
| from        | TEXT           | ‚Äì              |   |
| to          | LIST<TEXT>     | ‚Äì              |   |
| subject     | TEXT           | ‚Äì              |   |
| body        | TEXT           | ‚Äì              |   |
| attachments | LIST\<filename | size>          | ‚Äì |



This enables fetching email lists quickly, ordered by recency.

Query 3: Create/Delete/Get an Email

To retrieve an email‚Äôs full details, we query the emails_by_user table using email_id.

Attachments are handled separately in the attachments table because emails may contain multiple large attachments.


Table: attachments


| Column    | Type     | Key            |
| --------- | -------- | -------------- |
| email\_id | TIMEUUID | Partition Key  |
| filename  | TEXT     | Clustering Key |
| url       | TEXT     | ‚Äì              |


This separation avoids storing large files directly inside Cassandra.

Query 4: Fetch All Read or Unread Emails
Problem

In relational databases, filtering by is_read is easy (WHERE is_read = true).

But in NoSQL (like Cassandra), queries are restricted to partition and clustering keys. Since is_read is neither, filtering cannot be done directly.

Solution: Denormalization

Create two separate tables:

read_emails

unread_emails

Emails move between the two tables when their read status changes.

Tables: read_emails & unread_emails

| Column     | Type     | Key            |
| ---------- | -------- | -------------- |
| user\_id   | UUID     | Partition Key  |
| folder\_id | UUID     | Partition Key  |
| email\_id  | TIMEUUID | Clustering Key |
| from       | TEXT     | ‚Äì              |
| subject    | TEXT     | ‚Äì              |
| preview    | TEXT     | ‚Äì              |



Query Example (Unread Emails):



SELECT * FROM unread_emails
WHERE user_id = <user_id> AND folder_id = <folder_id>
ORDER BY email_id;



This approach improves performance at scale, at the cost of added application complexity.

Bonus Point: Conversation Threads

Threads group related emails (replies + original message).

Email headers include fields used for reconstruction:

Header Field	


| Header Field    | Description                                             |
| --------------- | ------------------------------------------------------- |
| **Message-Id**  | Unique identifier for each email (generated by client). |
| **In-Reply-To** | ID of the parent email being replied to.                |
| **References**  | List of related message IDs in the chain.               |




Using these, email clients can build threaded views.

Consistency Trade-Off

Distributed systems must balance Consistency vs Availability (CAP theorem).

For email, Consistency is prioritized over Availability.

A mailbox is managed by a single primary.

During failover, clients cannot access the mailbox (reduced availability), but consistency of emails is guaranteed.

Attachment Store

Attachments are large files (up to 25MB), unsuitable for Cassandra because:

Blob size limit ‚Äì Practical limit is <1MB.

Row cache issue ‚Äì Large attachments consume too much memory.

Solution: Use object storage (e.g., Amazon S3) for attachments. Cassandra only stores references (metadata + URLs).

Distributed Cache

Recent emails are frequently accessed.

Redis is used as a cache for faster retrieval.

Redis supports lists and scaling, making it a good fit.

Search Store

Full-text search (by subject, body, sender, etc.) requires inverted indexes.

A distributed document store is used as the search layer (e.g., Elasticsearch).

Workflows
Email Sending Flow

Steps:

User action: User writes an email and clicks "Send". Request goes to load balancer.

Load balancer: Routes traffic to web servers while enforcing rate limits.

Web servers:

Validate email (size, format, etc.).

Check domain (if sender and recipient domains match ‚Üí spam/virus scan).

If valid:

Save to sender‚Äôs "Sent Folder".

Save to recipient‚Äôs "Inbox Folder".

Recipient can fetch email immediately via API (skip later steps).

Message queues:

If email passes validation ‚Üí add to outgoing queue.

If email fails validation ‚Üí move to error queue.

If attachments are too large, store them in object storage, saving only references in the queue.

SMTP outgoing workers:

Pull emails from queue.

Perform spam/virus checks.

Save copy in "Sent Folder".

Send to recipient mail server.

Monitoring:

If emails pile up in the outgoing queue:

Recipient‚Äôs server might be down ‚Üí retry with exponential backoff.

Not enough SMTP workers ‚Üí scale up consumers.




Email Deliverability

Setting up a mail server to send emails is easy, but making sure those emails actually land in the user‚Äôs inbox (and not in spam) is the hard part.
Since more than 50% of all emails sent are spam (Statista [19]), new mail servers usually have no reputation and risk being flagged as spam.
To improve deliverability, the following factors are important:

Dedicated IPs

Use dedicated IP addresses for sending emails.

Emails from new IPs (with no history) are more likely to be rejected by ISPs.

Dedicated IPs help build a reputation over time.

Classify Emails

Send different categories of emails (transactional, marketing, important notices) from different IPs.

If marketing emails and critical emails come from the same server, ISPs may classify all of them as promotional or spam.

Email Sender Reputation

New IP addresses must be ‚Äúwarmed up‚Äù gradually by sending a low volume of emails at first and slowly increasing it.

This helps build trust with providers like Gmail, Office365, Yahoo Mail, etc.

According to Amazon SES [20], warming up takes 2‚Äì6 weeks.

Ban Spammers Quickly

Detect and ban spammers immediately.

If spammers are not stopped, they can ruin the reputation of the entire server.

Feedback Processing

Set up feedback loops with ISPs to track delivery issues and complaints.

Helps keep complaint rates low and ban spam accounts fast.

Possible Outcomes:

Hard bounce ‚Üí Email rejected permanently (invalid recipient address).

Soft bounce ‚Üí Temporary failure (e.g., ISP server busy).

Complaint ‚Üí User marks the email as spam.

üëâ These are processed in separate queues for better handling.

Email Authentication

Phishing and pretexting account for 93% of breaches (Verizon, 2018 [21]).
To fight this, we use authentication mechanisms:

SPF (Sender Policy Framework) ‚Üí Verifies sender‚Äôs IP.

DKIM (DomainKeys Identified Mail) ‚Üí Ensures email content is not altered.

DMARC (Domain-based Message Authentication, Reporting, and Conformance) ‚Üí Aligns SPF & DKIM policies to reduce spoofing.

üìå Example: A Gmail header (Figure 8.9) shows SPF, DKIM, and DMARC all PASS, confirming authenticity.

Search

Email systems support basic and advanced search.

Basic search ‚Üí Finds keywords in subject or body.

Advanced search ‚Üí Filters by From, Subject, Unread, Attachments, etc.

Key Characteristics:

Every time an email is sent, received, or deleted, reindexing is required (many writes).

Search is only run when user queries (fewer reads).

üëâ Compared with Google Search, email search is different:


| Feature      | Google Search                    | Email Search                                 |
| ------------ | -------------------------------- | -------------------------------------------- |
| **Scope**    | Whole internet                   | User‚Äôs own mailbox                           |
| **Sorting**  | By relevance                     | By attributes (time, unread, has attachment) |
| **Indexing** | Takes time, may miss new results | Needs **near real-time** and **accurate**    |



Attachment Store

Attachments (up to 25 MB) are stored in object storage like Amazon S3 because:

Scalable and suitable for large files (images, videos, docs).

Why not Cassandra (NoSQL)?

Blob size limit ‚Üí Although it supports blobs up to 2GB, the practical limit is <1MB.

Row cache issue ‚Üí Attachments are large and consume too much memory.

Distributed Cache

Since users often load their most recent emails, caching them in memory improves performance.

Redis is a good choice because:

It supports lists,

Easy to scale,

Very fast for repeated lookups.

Search Store

Uses a distributed document store.

Built on inverted index (maps words ‚Üí documents) for fast full-text search.

Ensures accurate and near real-time email search.

Email Workflows

Two main workflows:

Email Sending Flow

Email Receiving Flow (not fully detailed in your text)

Email Sending Flow (Figure 8.6)
Steps:

User writes an email ‚Üí Clicks send in webmail ‚Üí Request goes to load balancer.

Load balancer ‚Üí Ensures rate limit is not exceeded ‚Üí Routes traffic to web servers.

Web servers handle:

Email validation (e.g., size limits).

If sender and recipient are on same domain:

Check for spam/virus.

Store in Sent Folder (sender) and Inbox (recipient) directly.

Recipient fetches via API ‚Üí No need to continue.

Message Queues:

If valid ‚Üí Email enters outgoing queue.

If attachment is too large ‚Üí Store in object store, save reference in message.

If invalid ‚Üí Email goes to error queue.

SMTP Outgoing Workers:

Pull from outgoing queue.

Check for spam/virus.

Storage Layer:

Save outgoing email in sender‚Äôs Sent Folder.

Send via SMTP:

SMTP workers send the email to recipient‚Äôs mail server.

Monitoring the Outgoing Queue

If many emails are stuck in queue:

Recipient‚Äôs server unavailable ‚Üí Retry with exponential backoff.

Not enough consumers (workers) ‚Üí Scale up SMTP workers.

üëâ The distributed message queue is crucial because it:

Enables asynchronous processing,

Decouples SMTP workers from web servers,

Makes scaling easier.


Option 1: Elasticsearch

The design for implementing email search using Elasticsearch is shown in Figure 8.10 (from the text).

Partitioning strategy:
Since most queries are made on a user‚Äôs own emails, we can group documents on the same Elasticsearch node using user_id as the partition key.

Request types:

Search request: Synchronous. The user waits for results after clicking the search button.

Send, Receive, Delete events: Asynchronous. These events trigger reindexing but do not require any immediate response related to search.

Reindexing process:

Managed via offline jobs.

Kafka is used as a buffer/decoupler between services that trigger reindexing and services that perform the actual reindexing.

Advantages of Elasticsearch:

Popular and widely used (as of June 2021).

Excellent support for full-text search.

Challenges:

Keeping Elasticsearch in sync with the primary email store is difficult.

Option 2: Custom Search Solution

Big email providers (e.g., Gmail, Outlook) often build custom search engines tailored to their needs.

Main challenge:

Disk I/O bottleneck ‚Äî indexing is write-heavy, and with petabytes of daily data and hundreds of thousands of emails per user, disk performance is critical.

LSM Tree (Log-Structured Merge-Tree):

A suitable data structure for write-heavy workloads.

Used in systems like Bigtable, Cassandra, RocksDB.

How it works:

New emails go into Level 0 (in-memory cache).

When memory reaches a threshold, data is merged into higher levels (Level 1, 2, ‚Ä¶ on disk).

Advantages:

Optimizes sequential writes.

Separates frequently changing data (e.g., folder metadata) from rarely changing data (emails themselves).

Reduces unnecessary updates on immutable data.

Reference: Search in Microsoft Exchange servers can provide deeper insights.

Feature Comparison: Elasticsearch vs Custom Search Engine


| Feature                | Elasticsearch                                                               | Custom Search Engine                                |
| ---------------------- | --------------------------------------------------------------------------- | --------------------------------------------------- |
| **Scalability**        | Scales reasonably well, but limited for very large workloads                | Easier to scale when optimized for email use case   |
| **System complexity**  | Requires maintaining **two systems**: metadata store + Elasticsearch        | Only one integrated system                          |
| **Data consistency**   | Two copies (metadata + Elasticsearch index). Hard to keep in sync           | Only one copy ‚Üí easier consistency                  |
| **Data loss**          | Can recover by rebuilding index from primary storage                        | No data loss issue                                  |
| **Development effort** | Easy to integrate, but at scale requires a **dedicated Elasticsearch team** | Very high engineering effort to design and maintain |


Rule of thumb:

Small-scale email system: Use Elasticsearch (quick and easy).

Large-scale system (like Gmail/Outlook): A custom solution is better, with search built natively into the database.

Scalability and Availability

Scalability:

User access patterns are independent ‚Üí system can scale horizontally (add more servers).

Availability:

Data is replicated across multiple data centers.

Users connect to the nearest mail server (low latency).

During network partitions, users can still access emails from backup data centers (Figure 8.12).

Step 4 ‚Äì Wrap Up

This chapter walked through designing large-scale email servers:

Gathering requirements ‚Üí functional and non-functional.

Back-of-the-envelope calculations to estimate scale.

High-level design:

Traditional servers and their limitations.

APIs, send/receive flows.

Metadata database design.

Email deliverability.

Search (Elasticsearch vs custom).

Scalability & availability.

Additional Talking Points (if extra time in interview)

Fault tolerance:

Handle node failures, network partitions, event delays.

Compliance:

Must follow regulations (e.g., GDPR for EU PII).

Support legal intercept requirements.

Security:

Protect against phishing, unsafe links, unauthorized access.

Add features like safe browsing, proactive alerts, encryption, confidential mode.

Optimizations:

Deduplicate attachments in group emails (don‚Äôt store multiple copies of the same file in object storage like S3).

Chapter Summary
Functional requirements

Send and receive emails

Fetch all emails

Filter by read/unread

Search emails

Anti-spam

Reliability (no data loss)

Non-functional requirements

Scalability

Storage-heavy system

Email protocols: POP, IMAP, SMTP

Email basics

Distributed mail servers

DNS MX record

Attachments (MIME format)

High-level design

Email sending flow

Email receiving flow

Key considerations

Choosing the right database

Data model and consistency trade-offs

Metadata database design

Email deliverability

Search (Elasticsearch or custom engine)

Scalability & availability

Other aspects

Fault tolerance (node failures, network issues, delays)

Compliance (GDPR, PII handling, legal intercept)

Security (phishing protection, safe browsing, email encryption, etc.)

Optimizations (attachment deduplication for group emails)


